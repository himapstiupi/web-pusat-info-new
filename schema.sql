-- 1. PROFILES & ROLES
-- Extends auth.users to store role and status
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text not null,
  full_name text,
  avatar_url text,
  -- Role: 'user' (public), 'admin' (content creator), 'superadmin' (approver)
  role text not null default 'user' check (role in ('user', 'admin', 'superadmin')),
  -- Status: 'pending' (waiting for approval), 'approved' (active), 'rejected' (denied)
  -- Default for 'admin' registration will remain 'pending' until Superadmin approves.
  status text not null default 'pending' check (status in ('pending', 'approved', 'rejected')), 
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table public.profiles enable row level security;

-- Policies for Profiles
create policy "Public profiles are viewable by everyone." 
  on profiles for select using (true);

create policy "Users can insert their own profile." 
  on profiles for insert with check (auth.uid() = id);

create policy "Users can update own profile." 
  on profiles for update using (auth.uid() = id);

-- 2. CATEGORIES
create table if not exists public.categories (
  id bigint generated by default as identity primary key,
  title text not null,
  slug text not null unique,
  description text,
  icon text, -- Material Symbol name (e.g., 'security')
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table public.categories enable row level security;

-- Policies for Categories
create policy "Categories are viewable by everyone." 
  on categories for select using (true);

create policy "Admins and Superadmins can insert categories." 
  on categories for insert with check (
    exists (select 1 from profiles where id = auth.uid() and role in ('admin', 'superadmin') and status = 'approved')
  );

create policy "Admins and Superadmins can update categories." 
  on categories for update using (
    exists (select 1 from profiles where id = auth.uid() and role in ('admin', 'superadmin') and status = 'approved')
  );

create policy "Admins and Superadmins can delete categories." 
  on categories for delete using (
    exists (select 1 from profiles where id = auth.uid() and role in ('admin', 'superadmin') and status = 'approved')
  );

-- 3. ARTICLES
-- ID is TEXT (Slug) derived from Title, as requested.
create table if not exists public.articles (
  id text primary key, -- The Slug is the ID (e.g. 'cara-login')
  title text not null,
  content text, -- HTML or Markdown
  excerpt text,
  image_url text, -- Cover image
  category_id bigint references categories(id) on delete set null,
  author_id uuid references profiles(id) on delete set null,
  is_published boolean default false,
  views integer default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table public.articles enable row level security;

-- Policies for Articles
create policy "Published articles are viewable by everyone." 
  on articles for select using (is_published = true);

create policy "Admins see all articles." 
  on articles for select using (
    exists (select 1 from profiles where id = auth.uid() and role in ('admin', 'superadmin'))
  );

create policy "Admins can insert articles." 
  on articles for insert with check (
    exists (select 1 from profiles where id = auth.uid() and role in ('admin', 'superadmin') and status = 'approved')
  );

create policy "Admins can update articles." 
  on articles for update using (
    exists (select 1 from profiles where id = auth.uid() and role in ('admin', 'superadmin') and status = 'approved')
  );

create policy "Admins can delete articles." 
  on articles for delete using (
    exists (select 1 from profiles where id = auth.uid() and role in ('admin', 'superadmin') and status = 'approved')
  );

-- 4. TRIGGER FOR NEW USER SIGNUP
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name, role, status)
  values (
    new.id, 
    new.email, 
    new.raw_user_meta_data->>'full_name',
    -- Default to 'user' role, but we can handle 'admin' logic in the frontend 
    -- or assume all public registers via /register are 'admin' candidates.
    -- For safety, we'll default to 'user', but if the metadata says 'intent: admin', we set 'admin'.
    -- However, to keep it simple per requirements:
    -- "Register admin... Superadmin approves".
    -- We will default public signups to 'admin' role but 'pending' status? 
    -- Or better: Default 'user'. A user can 'apply' to be admin?
    -- User requirement: "fitur register admin tidak sembarangan... admin register dulu... superadmin acc".
    -- Implies the register page creates an Admin Candidate provided they use the specific register page.
    coalesce(new.raw_user_meta_data->>'role', 'user'), -- Use role from metadata or default 'user'
    'pending' -- Always pending initially
  );
  return new;
end;
$$ language plpgsql security definer;

-- Recreate trigger
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- 5. SEED DATA (Optional Categories)
insert into categories (title, slug, description, icon) values
('Panduan Pengguna', 'panduan-pengguna', 'Panduan lengkap penggunaan.', 'person'),
('Akun & Keamanan', 'akun-keamanan', 'Info keamanan dan privasi.', 'security'),
('Pembayaran', 'pembayaran', 'Info tagihan dan metode bayar.', 'payments');
